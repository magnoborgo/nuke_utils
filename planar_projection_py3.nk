set cut_paste_input [stack 0]
version 14.0 v1
push 0
push $cut_paste_input
Group {
inputs 2
name PlanarProjection1
help "<b>Planar Projection</b>\n\nGenerates 2D coordinates for points in 3D space. Type in 3D point coordinates, or use vertex selection in 3D viewer and click set to pick average of selected points, or set points to set all four points at once. You can connect node output to scene together with your pointcloud or geometry and see where your points are located in 3d space. Double click any of them to move it in 3d space like any traditional nuke transform control.\n\nA matrix transform is also generated to be used with RotoPaint, SplineWarp and GridWarp nodes.\n\nIf you are using matrix in GridWarp, points have to be in clockwise order, pick them one by one! Command set points doesn't respect selection order!\n\nCheck out the demo video on my website!\n\nKudos to Ivan Busquets for help with matrix math.\n\n--\ndeveloped by Vit Sedlacek (c)2012\nwww.vitsedlacek.com\n\n-- \nModified by Jed Smith to make calculation time nearly instantaneous, fix some bugs and create a BG input so that the sampled format could be easily specified instead of using nuke.root() format. Also enabled animated 3d input points, and added some functionality in the set knobs to snarf data from axis nodes."
selected true
xpos -283
ypos 360
addUserKnob {20 PlanarProjection}
addUserKnob {26 inputtab l <b>input}
addUserKnob {22 setAll l " Set Points to Selected " t "Set value of all points If Axis nodes are selected, it grabs translate values from them. If not, the first 4 selected vertexes in the 3D viewport is used instead. " T "## Set points to selected\n\nfrom nukescripts import snap3d as sn\n\nn = nuke.thisNode()\n\n# See if we have selected Axes in the last selected node\nwith nuke.Root():\n    axis_nodes = nuke.selectedNodes()\nif axis_nodes:\n    axis_nodes = list(reversed(axis_nodes)) # Reverse selected so it goes in selection order\n    for i in range(4):\n        if i > len(axis_nodes)-1:\n            break\n        point = n\['ip'+str(i+1)]\n        axis = axis_nodes\[i]\n        if 'Axis' in axis.Class():\n            if axis\['translate'].isAnimated():\n                point.clearAnimated()\n                point.copyAnimations(axis\['translate'].animations())\n            else:\n                point.clearAnimated()\n                point.setValue(axis\['translate'].getValue())\n# If no Axis nodes selected, let's try to get points from the selected vertexes in the 3d view\nif 'Axis2' not in \[n.Class() for n in axis_nodes]:\n    gen = None\n    points = None\n    gen = sn.selectedPoints()\n    points = \[point for point in gen]\n    if len(points) >= 4:\n        for i in range(4):\n            n\['ip'+str(i+1)].setValue(points\[i])" +STARTLINE}
addUserKnob {22 clear_input l Clear t "Remove all animated and non-default knob values." -STARTLINE T "n = nuke.thisNode()\n\nfor i in range(4):\n    kip = n\['ip'+str(i+1)]\n    kip.clearAnimated()\n    kip.setValue(kip.defaultValue())"}
addUserKnob {41 ip1 l "point 1" T point_1.translate}
addUserKnob {22 set1 l set t "Set the value to the currently selected Axis or the average position of the currently selected vertexes in the 3D view." -STARTLINE T "from __future__ import with_statement\nfrom nukescripts import snap3d as sn\n\nn = nuke.thisNode()\nk = nuke.thisKnob()\n\npoint_knob = n\['ip'+k.name()\[-1]]\n\n# See if we have selected Axes in the last selected node\nwith nuke.Root():\n    axis_nodes = nuke.selectedNodes()\nif axis_nodes:\n    axis = axis_nodes\[-1]\n    if 'Axis' in axis.Class():\n        if axis\['translate'].isAnimated():\n            point_knob.clearAnimated()\n            point_knob.copyAnimations(axis\['translate'].animations())\n        else:\n            point_knob.clearAnimated()\n            point_knob.setValue(axis\['translate'].getValue())\n# If no Axis nodes selected, let's try to get points from the selected vertexes in the 3d view\nif 'Axis' not in \[n.Class() for n in axis_nodes]:\n    gen = None\n    points = None\n    gen = sn.selectedPoints()\n    points = \[point for point in gen]\n    if len(points) > 0:\n        x = 0\n        y = 0\n        z = 0\n        for point in points:\n             x+=point\[0]\n             y+=point\[1]\n             z+=point\[2]\n        x = float(x / len(points))\n        y = float(y / len(points))\n        z = float(z / len(points))\n        point_knob.setValue(\[x,y,z])"}
addUserKnob {41 ip2 l "point 2" T point_2.translate}
addUserKnob {22 set2 l set t "Set the value to the currently selected Axis or the average position of the currently selected vertexes in the 3D view." -STARTLINE T "from __future__ import with_statement\nfrom nukescripts import snap3d as sn\n\nn = nuke.thisNode()\nk = nuke.thisKnob()\n\npoint_knob = n\['ip'+k.name()\[-1]]\n\n# See if we have selected Axes in the last selected node\nwith nuke.Root():\n    axis_nodes = nuke.selectedNodes()\nif axis_nodes:\n    axis = axis_nodes\[-1]\n    if 'Axis' in axis.Class():\n        if axis\['translate'].isAnimated():\n            point_knob.clearAnimated()\n            point_knob.copyAnimations(axis\['translate'].animations())\n        else:\n            point_knob.clearAnimated()\n            point_knob.setValue(axis\['translate'].getValue())\n# If no Axis nodes selected, let's try to get points from the selected vertexes in the 3d view\nif 'Axis' not in \[n.Class() for n in axis_nodes]:\n    gen = None\n    points = None\n    gen = sn.selectedPoints()\n    points = \[point for point in gen]\n    if len(points) > 0:\n        x = 0\n        y = 0\n        z = 0\n        for point in points:\n             x+=point\[0]\n             y+=point\[1]\n             z+=point\[2]\n        x = float(x / len(points))\n        y = float(y / len(points))\n        z = float(z / len(points))\n        point_knob.setValue(\[x,y,z])"}
addUserKnob {41 ip3 l "point 3" T point_3.translate}
addUserKnob {22 set3 l set t "Set the value to the currently selected Axis or the average position of the currently selected vertexes in the 3D view." -STARTLINE T "from __future__ import with_statement\nfrom nukescripts import snap3d as sn\n\nn = nuke.thisNode()\nk = nuke.thisKnob()\n\npoint_knob = n\['ip'+k.name()\[-1]]\n\n# See if we have selected Axes in the last selected node\nwith nuke.Root():\n    axis_nodes = nuke.selectedNodes()\nif axis_nodes:\n    axis = axis_nodes\[-1]\n    if 'Axis' in axis.Class():\n        if axis\['translate'].isAnimated():\n            point_knob.clearAnimated()\n            point_knob.copyAnimations(axis\['translate'].animations())\n        else:\n            point_knob.clearAnimated()\n            point_knob.setValue(axis\['translate'].getValue())\n# If no Axis nodes selected, let's try to get points from the selected vertexes in the 3d view\nif 'Axis' not in \[n.Class() for n in axis_nodes]:\n    gen = None\n    points = None\n    gen = sn.selectedPoints()\n    points = \[point for point in gen]\n    if len(points) > 0:\n        x = 0\n        y = 0\n        z = 0\n        for point in points:\n             x+=point\[0]\n             y+=point\[1]\n             z+=point\[2]\n        x = float(x / len(points))\n        y = float(y / len(points))\n        z = float(z / len(points))\n        point_knob.setValue(\[x,y,z])"}
addUserKnob {41 ip4 l "point 4" T point_4.translate}
addUserKnob {22 set4 l set t "Set the value to the currently selected Axis or the average position of the currently selected vertexes in the 3D view." -STARTLINE T "from __future__ import with_statement\nfrom nukescripts import snap3d as sn\n\nn = nuke.thisNode()\nk = nuke.thisKnob()\n\npoint_knob = n\['ip'+k.name()\[-1]]\n\n# See if we have selected Axes in the last selected node\nwith nuke.Root():\n    axis_nodes = nuke.selectedNodes()\nif axis_nodes:\n    axis = axis_nodes\[-1]\n    if 'Axis' in axis.Class():\n        if axis\['translate'].isAnimated():\n            point_knob.clearAnimated()\n            point_knob.copyAnimations(axis\['translate'].animations())\n        else:\n            point_knob.clearAnimated()\n            point_knob.setValue(axis\['translate'].getValue())\n# If no Axis nodes selected, let's try to get points from the selected vertexes in the 3d view\nif 'Axis' not in \[n.Class() for n in axis_nodes]:\n    gen = None\n    points = None\n    gen = sn.selectedPoints()\n    points = \[point for point in gen]\n    if len(points) > 0:\n        x = 0\n        y = 0\n        z = 0\n        for point in points:\n             x+=point\[0]\n             y+=point\[1]\n             z+=point\[2]\n        x = float(x / len(points))\n        y = float(y / len(points))\n        z = float(z / len(points))\n        point_knob.setValue(\[x,y,z])"}
addUserKnob {26 outputtab l <b>output}
addUserKnob {22 Calculate t "Calculate the reconciled 2D points for each 3D point.\n\nAlso calculate a matrix transform for the planar surface, if there are 4 total points. This can then be used for Rotos and CornerPins." -STARTLINE T "import nuke\nfrom nukescripts import snap3d as sn\nimport math\n\n\ndef cameraProjectionMatrix(cameraNode, frame, imageformat):\n    ## modified code from nukescripts/Snap3D\n\n    # Matrix to transform points into camera-relative coords.\n    wm = nuke.math.Matrix4()\n    for i in range(16):\n        wm\[i] = cameraNode\['matrix'].getValueAt(frame,i)\n    \n    wm.transpose()\n    camTransform = wm.inverse()\n\n    # Matrix to take the camera projection knobs into account\n    roll = float(cameraNode\['winroll'].getValueAt(frame,0))\n    scale_x = float(cameraNode\['win_scale'].getValueAt(frame,0))\n    scale_y = float(cameraNode\['win_scale'].getValueAt(frame,1))\n    translate_x = float(cameraNode\['win_translate'].getValueAt(frame,0))\n    translate_y = float(cameraNode\['win_translate'].getValueAt(frame,1))\n    m = nuke.math.Matrix4()\n    m.makeIdentity()\n    m.rotateZ(math.radians(roll))\n    m.scale(1.0 / scale_x, 1.0 / scale_y, 1.0)\n    m.translate(-translate_x, -translate_y, 0.0)\n\n    # Projection matrix based on the focal length, aperture and clipping planes of the camera\n    focal_length = float(cameraNode\['focal'].getValueAt(frame))\n    h_aperture = float(cameraNode\['haperture'].getValueAt(frame))\n    near = float(cameraNode\['near'].getValueAt(frame))\n    far = float(cameraNode\['far'].getValueAt(frame))\n    projection_mode = int(cameraNode\['projection_mode'].getValueAt(frame))\n    p = nuke.math.Matrix4()\n    p.projection(focal_length / h_aperture, near, far, projection_mode == 0)\n\n    # Matrix to translate the projected points into normalised pixel coords\n    imageAspect = float(imageformat.height()) / float(imageformat.width())\n    \n    t = nuke.math.Matrix4()\n    t.makeIdentity()\n    t.translate( 1.0, 1.0 - (1.0 - imageAspect / float(imageformat.pixelAspect())), 0.0 )\n\n    # Matrix to scale normalised pixel coords into actual pixel coords.\n    x_scale = float(imageformat.width()) / 2.0\n    y_scale = x_scale * imageformat.pixelAspect()\n    s = nuke.math.Matrix4()\n    s.makeIdentity()\n    s.scale(x_scale, y_scale, 1.0)\n  \n    # The projection matrix transforms points into camera coords, modifies based\n    # on the camera knob values, projects points into clip coords, translates the\n    # clip coords so that they lie in the range 0,0 - 2,2 instead of -1,-1 - 1,1,\n    # then scales the clip coords to proper pixel coords.\n    return s * t * p * m * camTransform\n\n\n\ndef pointsToMatrix(frame, node):\n    cpToMtx = nuke.math.Matrix4()\n    cpFromMtx = nuke.math.Matrix4()\n \n    # Get a list of Vector2 objects for each of the 'to' knobs and each of the 'from' knobs.\n    ToVectors = \[nuke.math.Vector2(node\[f].getValueAt(frame,0), node\[f].getValueAt(frame,1)) for f in sorted(node.knobs().keys()) if f.startswith('op')]\n\n    # Feed all 4 coordinates into the mapUnitSquareToQuad() function\n    cpToMtx.mapUnitSquareToQuad(ToVectors\[0].x, ToVectors\[0].y, ToVectors\[1].x, ToVectors\[1].y, ToVectors\[2].x, ToVectors\[2].y, ToVectors\[3].x, ToVectors\[3].y)\n\n    cpFromMtx.mapUnitSquareToQuad(0, 0, node.width(), 0, node.width(), node.height(), 0, node.height())\n\n    transform_matrix = cpToMtx * cpFromMtx.inverse()\n\n    # This is not needed to apply the transformation. The matrix is already correct. \n    # However, the matrix knob in rotopaint is indexed differently (row major), so I just transpose the matrix here to make it easier to copy its values to the knob\n    transform_matrix.transpose()\n\n    # Fill in the transform_matrix knob of the target node\n    return transform_matrix\n\n\n\ndef projectPoints(frame, camera=None, point=None, imageformat=None):\n    # Modify projectpoint function in nukescripts.snap3d to add frame argument\n    if not imageformat:\n        imageformat = nuke.root()\['format'].value()\n    camMatrix = cameraProjectionMatrix(camera, frame, imageformat)\n    if camMatrix == None:\n        raise RuntimeError(\"snap3d.cameraProjectionMatrix() returned None for camera.\")\n    \n    if not ( isinstance(point, list) or isinstance(point, tuple) ):\n        raise ValueError(\"Argument point must be a list or tuple.\")\n \n    for point in point:\n        # Would be nice to not do this for every item but since lists/tuples can\n        # containg anything...\n        if isinstance(point, nuke.math.Vector3):\n            pt = point\n        elif isinstance(point, list) or isinstance(point, tuple):\n            pt = nuke.math.Vector3(point\[0], point\[1], point\[2])\n        else:\n            raise ValueError(\"All items in point must be nuke.math.Vector3 or list/tuple of 3 floats.\")\n\n        tPos = camMatrix * nuke.math.Vector4(pt.x, pt.y, pt.z, 1.0)\n        #print tPos\n        try:\n            yield nuke.math.Vector2(tPos.x / tPos.w, tPos.y / tPos.w)\n        except ZeroDivisionError:\n            print(\"Zero Division Error on frame \{0\} with point data \{1\}\".format(frame, point))\n            yield nuke.math.Vector2()\n\n\ndef calculate(node):\n    # Get the input Camera and verify it is right. (Assume camera is topnode of input to handle dots)\n    cam_input = node.input(1)\n    # Sanity check \n    if not (cam_input and isinstance(cam_input, nuke.Node)):\n        nuke.message(\"A Camera node must be connected.\")\n        return\n    if 'Camera' in cam_input.Class():\n        cam = cam_input\n    else:\n        cam = nuke.toNode(nuke.tcl(\"full_name \[topnode %s]\" % cam_input.name()))\n    bg = node.input(0)\n    if not bg:\n        nuke.message(\"BG not connected, so the root format will be used to reconcile the 3D points into screen space.\")\n\n    # Get framerange to operate on from camera animation curves\n    first = None\n    last = None\n    try:\n        if cam\['translate'].isAnimated():        \n            for curve in cam\['translate'].animations():\n                if first == None:\n                    first = int(list(curve.keys())\[0].x)\n                else:\n                    first = min(first, int(list(curve.keys())\[0].x))\n            for curve in cam\['translate'].animations():\n                if last == None:\n                    last = int(list(curve.keys())\[-1].x)\n                else:\n                    last = max(last, int(list(curve.keys())\[-1].x))\n        elif cam\['rotate'].isAnimated():\n            for curve in cam\['rotate'].animations():\n                if first == None:\n                    first = int(list(curve.keys())\[0].x)\n                else:\n                    first = min(first, int(list(curve.keys())\[0].x))\n            for curve in cam\['rotate'].animations():\n                if last == None:\n                    last = int(list(curve.keys())\[-1].x)\n                else:\n                    last = max(last, int(list(curve.keys())\[-1].x))\n        else:\n            nuke.message(\"Input Camera is not animated.\")\n            return\n    except:\n        nuke.message(\"Something went wrong getting the camera animation. Using Root framerange...\")\n        first = nuke.root().firstFrame()\n        last = nuke.root().lastFrame()\n\n\n    framerange = nuke.FrameRange('\{0\}-\{1\}'.format(first, last))\n    \n    # Loop through the 3D points, reconcile the coordinates through the camera into screen space\n    for opnum in range(4):\n        # Only run if the ip knob is not default\n        ipknob = node\[\"ip\{0\}\".format(opnum+1)]\n        if not ipknob.notDefault():\n            print(\"Skipping \{0\} because it is still default!\".format('ip'+str(opnum+1)))\n            continue\n\n        opknob = node\[\"op\{0\}\".format(opnum+1)]\n        opknob.clearAnimated()\n        opknob.setAnimated()\n\n        # Building the data into a list of AnimationKey objects,\n        # and then applying that list to the knob using addKey is significantly faster than other methods.\n        # This makes the Calculate button instantaneous instead of taking forever.\n        point_animcurve = \[\[], \[]]\n        for frame in framerange:\n            \n            #print \"values are \", ipknob.getValueAt(frame)\n            # Sample input point knob on every frame if it's animated or expression-linked\n            if ipknob.isAnimated() or ipknob.hasExpression():\n                point = next(projectPoints(frame, cam, \[ipknob.getValueAt(frame)], node.format()))\n            else:\n                point = next(projectPoints(frame, cam, \[ipknob.value()], node.format()))\n            for index in range(2):\n                point_animcurve\[index].append(nuke.AnimationKey(frame, point\[index]))\n\n        for index, curve in enumerate(opknob.animations()):\n            curve.addKey(point_animcurve\[index])\n\n    # Calculate the transformation Matrix, if we have 4 output points\n    for i in range(4):\n        ipknob = node\[\"op\{0\}\".format(i+1)]\n        #print 'op'+str(i+1)+' IS NOT DEFAULT'\n        if not ipknob.notDefault():\n            return\n    mknob = node\['matrix']\n    mknob.clearAnimated()\n    mknob.setAnimated()\n    \n    matrix_animcurve = \[\[] for i in range(16)]\n    for frame in framerange:\n        matrix_data = pointsToMatrix(frame, node)\n        for index in range(16):\n            matrix_animcurve\[index].append(nuke.AnimationKey(frame, matrix_data\[index]))\n    for index, item in enumerate(mknob.animations()):\n        item.addKey(matrix_animcurve\[index])\n\nif __name__==\"__main__\":\n    calculate(nuke.thisNode())"}
addUserKnob {22 clear_out l Clear t "Clear output knobs." -STARTLINE T "n = nuke.thisNode()\n\nfor i in range(4):\n    kop = n\['op'+str(i+1)]\n    kop.clearAnimated()\n    kop.setValue(kop.defaultValue())\n    n\['matrix'].clearAnimated()\n    n\['matrix'].setValue(\[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])"}
addUserKnob {12 op1 l "point 1"}
addUserKnob {12 op2 l "point 2"}
addUserKnob {12 op3 l "point 3"}
addUserKnob {12 op4 l "point 4"}
addUserKnob {41 matrix T dummyAxis.matrix}
addUserKnob {20 endGroup n -1}
addUserKnob {26 div2 l create}
addUserKnob {22 create_tracker l Tracker t "Create a Tracker3 class Tracker node, in case this is what you prefer to link roto shapes to." T "# Create tracker node \nfrom __future__ import with_statement\ngrid_x = int(nuke.toNode('preferences').knob('GridWidth').value())\ngrid_y = int(nuke.toNode('preferences').knob('GridHeight').value())\npproj = nuke.thisNode()\nwith nuke.root():\n    track_node = nuke.nodes.Tracker3()\n    track_node.setXYpos(pproj.xpos()-grid_x*0, pproj.ypos()+grid_y*2)\n    \[n.setSelected(False) for n in nuke.allNodes()]\n    track_node.setSelected(True)\n    enable_knobs = \['enable1', 'enable2', 'enable3', 'enable4']\n    trs_knobs = \['use_for1', 'use_for2', 'use_for3', 'use_for4']\n    track_knobs = \['track1', 'track2', 'track3', 'track4']\n\n    for k in enable_knobs:\n        track_node\[k].setValue(True)\n    for k in trs_knobs:\n        track_node\[k].setValue(7)\n    for track in track_knobs:\n        tknob = track_node\[track]\n        tknob.clearAnimated()\n        tknob.setAnimated()\n        for i, c in enumerate(tknob.animations()):\n            opknob = pproj\['op\{0\}'.format(track.split('track')\[-1])]\n            if opknob.isAnimated():\n                c.addKey(opknob.animation(i).keys())\n            else:\n                tknob.clearAnimated()\n    pproj\['tracker_eeg'].execute()" +STARTLINE}
addUserKnob {22 tracker_eeg l "Tracker EEG" -STARTLINE T "from __future__ import with_statement\nwith nuke.root():\n    track_node = nuke.selectedNode()\n    try:\n        track_node\[trs_knobs\[0]].setValue(1)\n        track_node\[trs_knobs\[0]].setValue(7)\n    except:\n        pass"}
addUserKnob {22 createRotoPaint l RotoPaint T "import nuke.rotopaint as rp\nimport _curvelib as cl\n\nnode = nuke.thisNode()\nmatrix = node\['matrix']\n\nfirst = None\nfor every in matrix.animations():\n    if first == None:\n        first = int(every.keys()\[0].x)\n    else:\n        first = min(first, int(every.keys()\[0].x))\n\nlast = None\nfor every in matrix.animations():\n    if last == None:\n        last = int(every.keys()\[0].x)\n    else:\n        last = max(last, int(every.keys()\[-1].x))\n\nif first != None and last != None:\n    nuke.root().begin()\n    p = nuke.createNode(\"RotoPaint\")\n    cKnob = p\['curves']\n    nLayer = rp.Layer(cKnob)\n    if node\['layer_name'].value() == \"\":\n        nLayer.name = node.name()\n    else:\n        nLayer.name = node\['layer_name'].value()\n\n    curve = \[cl.AnimCurve() for i in range(16)]\n\n    for f in range(first,last+1):\n        val = matrix.valueAt(f)\n        for i in range(16):\n            curve\[i].addKey(int(f), val\[i])\n\n    for y in range(1,5):\n        for x in range(1,5):\n            cell = ((y-1)*4)+x-1\n            nLayer.getTransform().setExtraMatrixAnimCurve(y-1,x-1, curve\[cell])\n\n    cKnob.rootLayer.append(nLayer)" +STARTLINE}
addUserKnob {22 createSplineWarp l SplineWarp -STARTLINE T "import nuke.rotopaint as rp\nimport _splinewarp as sw\nimport _curvelib as cl\nimport _curveknob as ck\n\nnode = nuke.thisNode()\nmatrix = node\['matrix']\n\nfirst = None\nfor every in matrix.animations():\n    if first == None:\n        first = int(every.keys()\[0].x)\n    else:\n        first = min(first, int(every.keys()\[0].x))\n\nlast = None\nfor every in matrix.animations():\n    if last == None:\n        last = int(every.keys()\[0].x)\n    else:\n        last = max(last, int(every.keys()\[-1].x))\n\nif first != None and last != None:\n    nuke.root().begin()\n    p = nuke.createNode(\"SplineWarp3\")\n    p\['boundary_bbox'].setValue(0)\n    cKnob = p\['curves']\n    nLayer = ck.Layer(cKnob)\n    if node\['layer_name'].value() == \"\":\n        nLayer.name = node.name()\n    else:\n        nLayer.name = node\['layer_name'].value()\n\n    curve = \[cl.AnimCurve() for i in range(16)]\n\n    for f in range(first,last+1):\n        val = matrix.valueAt(f)\n        for i in range(16):\n            curve\[i].addKey(int(f), val\[i])\n\n    for y in range(1,5):\n        for x in range(1,5):\n            cell = ((y-1)*4)+x-1\n            nLayer.getTransform().setExtraMatrixAnimCurve(y-1,x-1, curve\[cell])\n\n    cKnob.rootLayer.append(nLayer)"}
addUserKnob {22 createGridWarp l GridWarp -STARTLINE T "vPPm = nuke.thisNode()\['matrix']\nif vPPm.isAnimated():\n    nuke.root().begin()\n    gW = nuke.createNode(\"GridWarp3\")\n    gWm = gW\['source_grid_transform_matrix']\n    gWm.copyAnimations(vPPm.animations())"}
addUserKnob {22 createCPinMatchMove l "CornerPin Matchmove" T "node = nuke.thisNode()\n\np1 = node\['op1']\np2 = node\['op2']\np3 = node\['op3']\np4 = node\['op4']\n\nif p1.isAnimated() or p2.isAnimated() or p3.isAnimated() or p4.isAnimated():\n    nuke.root().begin()\n    cP = nuke.createNode(\"CornerPin2D\")\n    cP\['label'].setValue(\"frame %d\\nmatchmove\" % nuke.frame())\n    cP\['to1'].copyAnimations(p1.animations())\n    cP\['to2'].copyAnimations(p2.animations())\n    cP\['to3'].copyAnimations(p3.animations())\n    cP\['to4'].copyAnimations(p4.animations())\n    cP\['from1'].setValue(p1.value())\n    cP\['from2'].setValue(p2.value())\n    cP\['from3'].setValue(p3.value())\n    cP\['from4'].setValue(p4.value())" +STARTLINE}
addUserKnob {22 createCPinStab l "CornerPin Stabilize" -STARTLINE T "node = nuke.thisNode()\n\np1 = node\['op1']\np2 = node\['op2']\np3 = node\['op3']\np4 = node\['op4']\n\nif p1.isAnimated() or p2.isAnimated() or p3.isAnimated() or p4.isAnimated():\n    nuke.root().begin()\n    cP = nuke.createNode(\"CornerPin2D\")\n    cP\['label'].setValue(\"frame %d\\nstabilize\" % nuke.frame())\n    cP\['from1'].copyAnimations(p1.animations())\n    cP\['from2'].copyAnimations(p2.animations())\n    cP\['from3'].copyAnimations(p3.animations())\n    cP\['from4'].copyAnimations(p4.animations())\n    cP\['to1'].setValue(p1.value())\n    cP\['to2'].setValue(p2.value())\n    cP\['to3'].setValue(p3.value())\n    cP\['to4'].setValue(p4.value())"}
addUserKnob {26 ""}
addUserKnob {1 layer_name l "layer name"}
addUserKnob {22 add l "add layer to selected RotoPaint/Splinewarp nodes" T "node = nuke.thisNode()\nfor cNode in nuke.root().selectedNodes():\n    if cNode != None:\n        if cNode.Class() == \"SplineWarp3\" or cNode.Class() ==\"RotoPaint\" or cNode.Class() ==\"Roto\":\n            cKnob = cNode\['curves']\n            if cNode.Class() == \"RotoPaint\":\n                nLayer = rp.Layer(cKnob)\n            else:\n                nLayer = ck.Layer(cKnob)\n            \n            if node\['layer_name'].value() == \"\":\n                nLayer.name = node.name()\n            else:\n                nLayer.name = node\['layer_name'].value()\n\n\n            for y in range(1,5):\n                for x in range(1,5):\n                    cell = ((y-1)*4)+x-1\n                    nLayer.getTransform().setExtraMatrixAnimCurve(y-1,x-1, curve\[cell])\n\n            cKnob.rootLayer.append(nLayer)" +STARTLINE}
addUserKnob {26 ""}
addUserKnob {26 desc l "" +STARTLINE T "developed by Vit Sedlacek www.vitsedlacek.com\\n\noptimized and improved by Jed Smith"}
}
Input {
inputs 0
name InputCam
label "\[value number]"
xpos 400
ypos -301
number 1
}
Input {
inputs 0
name InputBG
label "\[value number]"
xpos 620
ypos -301
}
set Nd8aa2000 [stack 0]
Axis2 {
inputs 0
name point_4
xpos 300
ypos -270
}
Axis2 {
inputs 0
name point_3
xpos 190
ypos -270
}
Axis2 {
inputs 0
name point_2
xpos 80
ypos -270
}
Axis2 {
inputs 0
name point_1
xpos -30
ypos -271
}
Scene {
inputs 6
name Scene1
xpos 410
ypos -78
}
push $Nd8aa2000
Output {
name Output1
xpos 620
ypos 159
}
Axis2 {
inputs 0
useMatrix true
name dummyAxis
xpos -30
ypos -102
disable true
}
end_group
