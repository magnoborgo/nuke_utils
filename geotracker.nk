set cut_paste_input [stack 0]
version 12.2 v11
push $cut_paste_input
Group {
name GeoTracker
tile_color 0xcfff00ff
selected true
xpos 2682
ypos 2848
addUserKnob {20 User l GeoTracker}
addUserKnob {41 first l "Frame Range  " T MassPointMatcher.first}
addUserKnob {41 last l - -STARTLINE T MassPointMatcher.last}
addUserKnob {41 g l "      Get Viewer Range     " -STARTLINE T MassPointMatcher.g}
addUserKnob {26 ""}
addUserKnob {41 getVerts l INVISIBLE +INVISIBLE T MassPointMatcher.getVerts}
addUserKnob {41 dotrack l "    Track Selected Points    " T MassPointMatcher.dotrack}
addUserKnob {26 ""}
addUserKnob {26 a l INVISIBLE +INVISIBLE T ""}
addUserKnob {20 About}
addUserKnob {26 about l "" +STARTLINE T "Tracks selected 3D points position for specific Frame Range.\n\n1. Connect your Geometry to the node input.\n2. Adjust Frame Range as you need.\n3. in the 3DViewer select points you want to get tracked.\n5. Press Track Selected Points to execute tracking process.\n\nA new 'Match_Points' node will appear at the end of tracking, \nwith all track data exposed. You may create Axis nodes or\n2D tracker out of that info using dedicated Buttons inside.\nDon't forget to SET THE FORMAT, since Tracker is resolution\ndependent. For 2D tracker a RenderCamera needs to feed\nthe cam input.\n\n\n* No Progress bar indicator, since it slows down the process.\n* Dependent on your geometry complexity and number of\n  points it may take a few minutes to complete. This process\n  can't go any faster because of The Foundry genious API\n  design ,so just wait and be patient. Node is very stable,\n  so crashes are very unlikely to occur.\n\nThank You Ben Dickson for keyframes sorting magic!\n\nDaniel Velikov  © 2017  daniel_vfx@abv.bg\n"}
}
Input {
inputs 0
name geo
xpos -107
ypos 148
}
set N24849e00 [stack 0]
Output {
name Output1
xpos -107
ypos 359
}
push $N24849e00
FrameHold {
first_frame 1404
name FrameHold1
xpos -5
ypos 222
disable true
}
PythonGeo {
name MassPointMatcher
onCreate "def getWpoint(geoID,vtxID):\n    n=nuke.thisNode()\n    geo=n\['geo_select'].getGeometry()\[geoID]\n    mtx=geo.transform()\n    mtx.transpose()\n    p=geo.points()\[vtxID]\n    thePoint=nuke.math.Vector4(p.x,p.y,p.z,1.0)\n    thePoint=mtx*thePoint\n\n    return \[thePoint.x,thePoint.y,thePoint.z]\n\n"
knobChanged "if nuke.GUI:\n    n=nuke.thisNode()\n    k=nuke.thisKnob().name()\n    \n    if k=='seq':\n        sg=nuke_shotgun.getstuff.get_shotlist()\n        curseq=n\['seq'].value()\n        n\['shot'].setValues(\[i for i in sg\['sequences']\[curseq]])\n        n\['shot'].setValue(0)\n    if k=='cust_task':\n        ct=n\['custom_task']\n        if n\['cust_task'].value()=='<Custom>':\n            n\['custom_task'].setValue('<Custom>')\n            ct.setEnabled(True)\n            ct.setVisible(True)\n        else:\n            n\['custom_task'].setValue(n\['cust_task'].value())\n            ct.setVisible(False)\n    \n    if k=='seq' or k=='shot' or k=='task' or k=='cust_task' or k=='custom_task':\n        f=filterPath('/asset/'+nc\['job']+'/'+n\['seq'].value()+'/'+n\['shot'].value()+'/2d/'+n\['task'].value()+'/'+n\['custom_task'].value()+'/'+'exr/')\n        ver=findAssetversions(f)\n        n\['version'].setValues(ver)\n        n\['version'].setValue(max(ver))\n        n\['thePath'].setValue(f)"
xpos -5
ypos 273
addUserKnob {20 User}
addUserKnob {26 dvl l "Frame Range"}
addUserKnob {3 first l "  "}
first 1001
addUserKnob {3 last l - -STARTLINE}
last 1404
addUserKnob {22 g l "      Get Viewer Range     " -STARTLINE T "n=nuke.thisNode()\ntry:\n    v=nuke.activeViewer().node()\nexcept:\n    nuke.message('No Viewer detected in the script.')\nelse:\n    fr=v\['frame_range'].value().split('-')\n    if not(v\['frame_range_lock'].value()):\n        fr=str(nuke.root().frameRange()).split('-')\n    \n    n\['first'].setValue(int(fr\[0]))\n    n\['last'].setValue(int(fr\[1]))\n\n"}
addUserKnob {26 ""}
addUserKnob {22 getVerts l INVISIBLE +INVISIBLE T "n=nuke.thisNode()\ntxt=''\nx= n\['geo_select'].getSelection()\nvsel=\[]\nfor gidx,i in enumerate(x):\n    for vidx,j in enumerate(i):\n        if j==1.0:\n            vsel.append(\[gidx,vidx])\n            txt+='objID:\{\}   vertexID:\{\}   pos: \{\}\\n'.format(gidx,vidx,str(getWpoint(gidx,vidx))) \n\nif txt=='': txt=' '\nn\['a'].setValue(txt)\nnuke.thisParent()\['a'].setValue(txt)\n" +STARTLINE}
addUserKnob {22 dotrack l "    Track Selected Geo Points    " -STARTLINE T "n=nuke.thisNode()\n\nfhold=nuke.toNode('FrameHold1')\nx= n\['geo_select'].getSelection()\ndata=\[]\n\nfor gidx,i in enumerate(x):\n    for vidx,j in enumerate(i):\n        if j==1.0:\n            data.append(\[gidx,vidx])\n\nif len(data)<1:\n    nuke.message('Input must be connected to GeometryNode with at least one point selected.')\nelse:\n\ttrackData=\[]\n\tfirst=int(n\['first'].value())\n\tlast=int(n\['last'].value())+1\n\tfhold\['disable'].setValue(False)\n\tfor f in range(first,last):\n\t\tnuke.toNode('FrameHold1')\['first_frame'].setValue(f)\n\t\tfhold\['first_frame'].setValue(f)\n\t\tn.forceValidate()\n\t\tfor i in data:\n\t\t    trackData.append(\[f,i\[0],i\[1],getWpoint(i\[0],i\[1])])\n\n\tfhold\['disable'].setValue(True)\n\n\tnuke.root().begin()\n\n\tcontainer = nuke.createNode('Group')\n\tcontainer.setName('Match Points')\n\tcontainer\['tile_color'].setValue(3489595647)\n\twith container:\n\t    inp=nuke.nodes.Input()\n\t    inp.setName('cam')\n\t    out=nuke.nodes.Output()\n\tcontainer.addKnob(nuke.Tab_Knob('Controls'))\n\tcontainer.addKnob(nuke.Format_Knob('fmt','Format'))\n\tcontainer.addKnob(nuke.PyScript_Knob('doTracker','  Points To Tracker  '))\n\tcontainer.addKnob(nuke.PyScript_Knob('doAxis','  Points To Axis  '))\n\tcontainer.addKnob(nuke.Text_Knob(''))\n\tcontainer\['doTracker'].setFlag(nuke.STARTLINE)\n\n\t# BENS MAGIC!\n\tby_object = \{\}\n\tfor frame, obj1, obj2, pos in trackData:\n\t\tobjname = (obj1,obj2)\n\t\tdata = (frame, pos)\n\t\tby_object.setdefault(objname, \[]).append(data)\n\n\tfor object, animation in by_object.items():\n\n\t\tobjName='Axis_\{\}_\{\}'.format(object\[0],object\[1])\n\t\tobjLabel='Obj:\{\} Vertex:\{\}'.format(object\[0],object\[1])\n\t\tArrayKnob=nuke.Array_Knob(objName,objLabel,3)\n\t\tArrayKnob.setFlag(nuke.STARTLINE)\n\t\tcontainer.addKnob(ArrayKnob)\n\n\t\tArrayKnob.setAnimated()\n\t\tx, y, z = \[], \[], \[]\n\t\tfor frame, pos in sorted(animation):\n\t\t    x.append(nuke.AnimationKey(frame, pos\[0]))\n\t\t    y.append(nuke.AnimationKey(frame, pos\[1]))\n\t\t    z.append(nuke.AnimationKey(frame, pos\[2]))\n\n\t\tknob_anim = ArrayKnob.animation(0) # First (only) animated channel of knob\n\t\tknob_anim.clear()\n\t\tknob_anim.addKey(x)\n\n\t\tknob_anim = ArrayKnob.animation(1)\n\t\tknob_anim.clear()\n\t\tknob_anim.addKey(y)\n\n\t\tknob_anim = ArrayKnob.animation(2)\n\t\tknob_anim.clear()\n\t\tknob_anim.addKey(z)\n\n\n\tcontainer.addKnob(nuke.Tab_Knob('About'))\n\tcontainer.addKnob(nuke.Text_Knob('','','Daniel Velikov  © 2017'))\n\tcontainer\['Controls'].setFlag(0)\n\n\tcontainer\['doAxis'].setCommand(\"n=nuke.thisNode()\\nnuke.root().begin()\\npx=n.xpos()\\npy=n.ypos()\\nfor pp,i in enumerate(\[n\[i] for i in n.knobs() if i.startswith('Axis')]):\\n    a=nuke.Node('Axis')\\n    a.setName(i.name())\\n    a\['translate'].fromScript(i.toScript())\\n    a.connectInput(0,None)\\n    a.setXYpos(px+100*(pp+1),py)\")\n\n\tcontainer\['doTracker'].setCommand( \"import math \\ndef findC(cls='Camera',node=nuke.thisNode(),inp=0):\\n    obj=node.input(inp)\\n    if obj==None:\\n        return False\\n    if cls in obj.Class():\\n        return obj\\n    else:\\n        return findC(cls,obj,0)\\n\\ndef camPMatrix(cameraNode,theFrame,fmt): \\n\\n    tempMatrix=cameraNode\['world_matrix'].getValueAt(theFrame)\\n    theMatrix=nuke.math.Matrix4()\\n    for j in range(4):\\n        for i in range(4):\\n            theMatrix\[(j*4+i)]=tempMatrix\[i*4+j]\\n   \\n    camTransform = theMatrix.inverse()\\n\\n    roll = float(cameraNode\['winroll'].getValueAt(theFrame)) \\n    scale_x, scale_y = \[float(v) for v in cameraNode\['win_scale'].getValueAt(theFrame)] \\n    translate_x, translate_y = \[float(v) for v in cameraNode\['win_translate'].getValueAt(theFrame)] \\n    m = nuke.math.Matrix4() \\n    m.makeIdentity() \\n    m.rotateZ(math.radians(roll)) \\n    m.scale(1.0 / scale_x, 1.0 / scale_y, 1.0) \\n    m.translate(-translate_x, -translate_y, 0.0) \\n\\n    focal_length = float(cameraNode\['focal'].getValueAt(theFrame)) \\n    h_aperture = float(cameraNode\['haperture'].getValueAt(theFrame)) \\n    near = float(cameraNode\['near'].getValueAt(theFrame)) \\n    far = float(cameraNode\['far'].getValueAt(theFrame)) \\n    projection_mode = int(cameraNode\['projection_mode'].getValueAt(theFrame)) \\n    p = nuke.math.Matrix4() \\n    p.projection(focal_length / h_aperture, near, far, projection_mode == 0) \\n\\n    fw=float(fmt.width())\\n    fh=float(fmt.height())\\n    pxa=float(fmt.pixelAspect())\\n    asr=fw/(fh/pxa)\\n\\n    imageAspect = fh / fw\\n    t = nuke.math.Matrix4() \\n    t.makeIdentity() \\n    t.translate( 1.0, 1.0 - (1.0 - imageAspect / pxa), 0.0 ) \\n\\n    x_scale = fw *.5\\n    y_scale = x_scale * pxa \\n    s = nuke.math.Matrix4() \\n    s.makeIdentity() \\n    s.scale(x_scale, y_scale, 1.0) \\n\\n    return s * t * p * m * camTransform \\n\\ndef getScriptedTracks(theCamera):\\n    theNode=nuke.thisNode()\\n    #GetFormat\\n    theFormat=theNode\['fmt'].value()\\n\\n    #Get 3DKnobs\\n    knobNames=\[i for i in theNode.knobs() if i.startswith('Axis')]\\n\\n    #GetFrameRange\\n    TheFrameRange=theNode\[knobNames\[0]].getKeyList()\\n\\n    #Generate Data Array\\n    pointsData=\[]\\n    for i in knobNames:\\n        pointsData.append(\['\{curve ','\{curve '])\\n    #For Each Frame\\n    for idx,frame in enumerate(TheFrameRange):\\n        #Get Cam Matrix\\n        camMatrix=camPMatrix(camera,frame,theFormat)    \\n        #For each Point\\n        for pidx,knob in enumerate(knobNames):\\n            #Get Point coords \\n            point=theNode\[knob].getValueAt(frame)\\n            #Calculate ScreenCoordinates\\n            pt = nuke.math.Vector3(point\[0], point\[1], point\[2]) \\n            tPos = camMatrix * nuke.math.Vector4(pt.x, pt.y, pt.z, 1.0)\\n            cx,cy=0,0\\n            if tPos.x!=0:\\n                cx=tPos.x / tPos.w\\n            if tPos.y!=0:\\n                cy=tPos.y / tPos.w\\n            #Add Values to X,Y curves\\n            pointsData\[pidx]\[0]+='x\{\} \{\} '.format(frame,cx)\\n            pointsData\[pidx]\[1]+='x\{\} \{\} '.format(frame,cy)\\n    \\n    scriptString=\\\"\{ 1 31 \\\"\\n    scriptString+=str(len(knobNames))\\n    scriptString+=\\\" \} \\\\n\{ \{ 5 1 20 enable e 1 \} \\\\n\{ 3 1 75 name name 1 \} \\\\n\{ 2 1 58 track_x track_x 1 \} \\\\n\{ 2 1 58 track_y track_y 1 \} \\\\n\{ 2 1 63 offset_x offset_x 1 \} \\\\n\{ 2 1 63 offset_y offset_y 1 \} \\\\n\{ 4 1 27 T T 1 \} \\\\n\{ 4 1 27 R R 1 \} \\\\n\{ 4 1 27 S S 1 \} \\\\n\{ 2 0 45 error error 1 \} \\\\n\{ 1 1 0 error_min error_min 1 \} \\\\n\{ 1 1 0 error_max error_max 1 \} \\\\n\{ 1 1 0 pattern_x pattern_x 1 \} \\\\n\{ 1 1 0 pattern_y pattern_y 1 \} \\\\n\{ 1 1 0 pattern_r pattern_r 1 \} \\\\n\{ 1 1 0 pattern_t pattern_t 1 \} \\\\n\{ 1 1 0 search_x search_x 1 \} \\\\n\{ 1 1 0 search_y search_y 1 \} \\\\n\{ 1 1 0 search_r search_r 1 \} \\\\n\{ 1 1 0 search_t search_t 1 \} \\\\n\{ 2 1 0 key_track key_track 1 \} \\\\n\{ 2 1 0 key_search_x key_search_x 1 \} \\\\n\{ 2 1 0 key_search_y key_search_y 1 \} \\\\n\{ 2 1 0 key_search_r key_search_r 1 \} \\\\n\{ 2 1 0 key_search_t key_search_t 1 \} \\\\n\{ 2 1 0 key_track_x key_track_x 1 \} \\\\n\{ 2 1 0 key_track_y key_track_y 1 \} \\\\n\{ 2 1 0 key_track_r key_track_r 1 \} \\\\n\{ 2 1 0 key_track_t key_track_t 1 \} \\\\n\{ 2 1 0 key_centre_offset_x key_centre_offset_x 1 \} \\\\n\{ 2 1 0 key_centre_offset_y key_centre_offset_y 1 \} \\\\n\} \\\\n\{ \\\\n\\\"\\n\\n    startFrame=min(TheFrameRange)\\n    for pidx,knob in enumerate(knobNames):\\n        pointsData\[pidx]=' \{ \{curve K x'+str(startFrame)+' 1\} \\\"'+knob+'\\\" '+(pointsData\[pidx]\[0].rstrip()+'\} ')+(pointsData\[pidx]\[1].rstrip()+'\}')\\n        pointsData\[pidx]+=\\\" \{\}  \{\}  1 0 0 \{\}  0 0 0 0 0 0 0 0 0 0 \\\"\\n        pointsData\[pidx]+=(11*(\\\"\{curve 0 x\\\"+str(startFrame)+\\\" 0\} \\\")+\\\"   \}\\\\n\\\")\\n        scriptString+=pointsData\[pidx]\\n    \\n    scriptString+=\\\"\} \\\\n\\\"\\n    return scriptString\\n\\ndef createTracker(data):\\n    nuke.root().begin()\\n    trackNode = nuke.createNode('Tracker4')\\n    trackNode\['tracks'].fromScript(data)\\n    return trackNode\\n\\ncamera=findC('Camera',nuke.thisNode(),0)\\nif camera==False:\\n    nuke.message('Camera Not Found')\\nelse:\\n    xxx=getScriptedTracks(camera)\\n    createTracker(xxx)\")"}
addUserKnob {26 a l "" +STARTLINE T ""}
}
end_group
